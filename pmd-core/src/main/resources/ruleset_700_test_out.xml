<?xml version="1.0" encoding="UTF-8"?>
<ruleset xmlns="https://pmd-code.org/ruleset/7.0.0"
         xmlns:ns0="http://www.w3.org/2001/XMLSchema-instance"
         ns0:schemaLocation="https://pmd-code.org/ruleset/7.0.0 file:///home/clifrr/Documents/Git/pmd/pmd-core/src/main/resources/ruleset_700.xsd">
   <name>Code Style</name>

    <description>
        Rules which enforce a specific coding style.
    </description>

    <rule-def name="AvoidDollarSigns">
      <message>Each class should declare at least one constructor</message>
      <description>

            Each non-static class should declare at least one constructor.
            Classes with solely static members are ignored, refer to [UseUtilityClassRule](pmd_rules_java_design.html#useutilityclass) to detect those.
            
        </description>
      <since>1.04</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.AtLeastOneConstructorRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
   // missing constructor
  public void doSomething() { ... }
  public void doOtherThing { ... }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="AvoidDollarSigns">
      <message>Avoid using dollar signs in variable/method/class/interface names</message>
      <description>
            Avoid using dollar signs in variable/method/class/interface names.
        </description>
      <since>1.5</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.AvoidDollarSignsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Fo$o {  // not a recommended name
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="AvoidProtectedFieldInFinalClass">
      <message>Avoid protected fields in a final class.  Change to private or package access.</message>
      <description>
            Do not use protected fields in final classes since they cannot be subclassed.
            Clarify your intent by using private or package access modifiers instead.
        </description>
      <since>2.1</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration[@Final= true()]
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/FieldDeclaration[@Protected= true()]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public final class Bar {
  private int x;
  protected int y;  // bar cannot be subclassed, so is y really private or package visible?
  Bar() {}
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="AvoidProtectedMethodInFinalClassNotExtending">
      <message>Avoid protected methods in a final class that doesn't extend anything other than Object.  Change to private or package access.</message>
      <description>
            Do not use protected methods in most final classes since they cannot be subclassed. This should
            only be allowed in final classes that extend other classes with protected methods (whose
            visibility cannot be reduced). Clarify your intent by using private or package access modifiers instead.
        </description>
      <since>5.1</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration[@Final= true() and not(ExtendsList)]
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/MethodDeclaration[@Protected=true() and @Name != 'finalize']
 
                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public final class Foo {
  private int bar() {}
  protected int baz() {} // Foo cannot be subclassed, and doesn't extend anything, so is baz() really private or package visible?
}
 
        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="AvoidUsingNativeCode">
      <message>The use of native code is not recommended.</message>
      <description>
            Unnecessary reliance on Java Native Interface (JNI) calls directly reduces application portability
            and increases the maintenance burden.
        </description>
      <since>4.1</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[//Name[starts-with(@Image,'System.loadLibrary')]]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class SomeJNIClass {

     public SomeJNIClass() {
         System.loadLibrary("nativelib");
     }

     static {
         System.loadLibrary("nativelib");
     }

     public void invalidCallsInMethod() throws SecurityException, NoSuchMethodException {
         System.loadLibrary("nativelib");
     }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="BooleanGetMethodName">
      <message>A 'getX()' method which returns a boolean should be named 'isX()'</message>
      <description>
            Methods that return boolean results should be named as predicate statements to denote this.
            I.e, 'isReady()', 'hasValues()', 'canCommit()', 'willFail()', etc.   Avoid the use of the 'get'
            prefix for these methods.
        </description>
      <since>4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//MethodDeclaration
    [starts-with(@Name, 'get')]
    [@Arity = 0 or $checkParameterizedMethods = true()]
    [
        ResultType/Type/PrimitiveType[@Image = 'boolean']
        and not(../Annotation//Name[@Image = 'Override'])
    ]

                ]]></expr>
            <property-defs>
               <property-def name="checkParameterizedMethods">
                  <type>Boolean</type>
                  <description>Check parameterized methods</description>
                  <default-value>
                     <value>false</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public boolean getFoo();            // bad
public boolean isFoo();             // ok
public boolean getFoo(boolean bar); // ok, unless checkParameterizedMethods=true

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="CallSuperInConstructor">
      <message>It is a good practice to call super() in a constructor</message>
      <description>
            It is a good practice to call super() in a constructor. If super() is not called but
            another constructor (such as an overloaded constructor) is called, this rule will not report it.
        </description>
      <since>3.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration[ExtendsList/*]
/ClassOrInterfaceBody
 /ClassOrInterfaceBodyDeclaration
 /ConstructorDeclaration[ not(.//ExplicitConstructorInvocation) ]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo extends Bar{
  public Foo() {
   // call the constructor of Bar
   super();
  }
 public Foo(int code) {
  // do something with code
   this();
   // no problem with this
  }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ClassNamingConventions">
      <message>The {0} name ''{1}'' doesn''t match ''{2}''</message>
      <description>
            Configurable naming conventions for type declarations. This rule reports
            type declarations which do not match the regex that applies to their
            specific kind (e.g. enum or interface). Each regex can be configured through
            properties.

            By default this rule uses the standard Java naming convention (Pascal case),
            and reports utility class names not ending with 'Util'.
        </description>
      <since>1.2</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.ClassNamingConventionsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
// This is Pascal case, the recommended naming convention in Java
// Note that the default values of this rule don't allow underscores
// or accented characters in type names
public class FooBar {}

// You may want abstract classes to be named 'AbstractXXX',
// in which case you can customize the regex for abstract
// classes to 'Abstract[A-Z]\w+'
public abstract class Thing {}

// This class doesn't respect the convention, and will be flagged
public class Éléphant {}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="CommentDefaultAccessModifier">
      <message>Missing commented default access modifier</message>
      <description>
            To avoid mistakes if we want that an Annotation, Class, Enum, Method, Constructor or Field have a default access modifier
            we must add a comment at the beginning of it's declaration.
            By default the comment must be `/* default */` or `/* package */`, if you want another, you have to provide a regular expression.
            This rule ignores by default all cases that have a @VisibleForTesting annotation. Use the
            property "ignoredAnnotations" to customize the recognized annotations.
        </description>
      <since>5.4.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.CommentDefaultAccessModifierRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
    final String stringValue = "some string";
    String getString() {
       return stringValue;
    }

    class NestedFoo {
    }
}

// should be
public class Foo {
    /* default */ final String stringValue = "some string";
    /* default */ String getString() {
       return stringValue;
    }

    /* default */ class NestedFoo {
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ConfusingTernary">
      <message>Avoid if (x != y) ..; else ..;</message>
      <description>
            Avoid negation within an "if" expression with an "else" clause.  For example, rephrase:
            `if (x != y) diff(); else same();` as: `if (x == y) same(); else diff();`.

            Most "if (x != y)" cases without an "else" are often return cases, so consistent use of this
            rule makes the code easier to read.  Also, this resolves trivial ordering problems, such
            as "does the error case go first?" or "does the common case go first?".
        </description>
      <since>1.9</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.ConfusingTernaryRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
boolean bar(int x, int y) {
    return (x != y) ? diff : same;
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ControlStatementBraces">
      <message>This statement should have braces</message>
      <description>
            Enforce a policy for braces on control statements. It is recommended to use braces on 'if ... else'
            statements and loop statements, even if they are optional. This usually makes the code clearer, and
            helps prepare the future when you need to add another statement. That said, this rule lets you control
            which statements are required to have braces via properties.

            From 6.2.0 on, this rule supersedes WhileLoopMustUseBraces, ForLoopMustUseBraces, IfStmtMustUseBraces,
            and IfElseStmtMustUseBraces.
        </description>
      <since>6.2.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                //WhileStatement[$checkWhileStmt and not(Statement/Block) and not($allowEmptyLoop and Statement/EmptyStatement)]
                |
                //ForStatement[$checkForStmt and not(Statement/Block) and not($allowEmptyLoop and Statement/EmptyStatement)]
                |
                //DoStatement[$checkDoWhileStmt and not(Statement/Block) and not($allowEmptyLoop and Statement/EmptyStatement)]
                |
                (: The violation is reported on the sub statement -- not the if statement :)
                //Statement[$checkIfElseStmt and parent::IfStatement and not(child::Block or child::IfStatement)
                            (: Whitelists single if statements :)
                            and ($checkSingleIfStmt
                                 (: Inside this not(...) is the definition of a "single if statement" :)
                                 or not(count(../Statement) = 1 (: No else stmt :)
                                        (: Not the last branch of an 'if ... else if' chain :)
                                        and not(parent::IfStatement[parent::Statement[parent::IfStatement]])))]
                |
                (: Reports case labels if one of their subordinate statements is not braced :)
                //SwitchLabel[$checkCaseStmt]
                             [count(following-sibling::BlockStatement except following-sibling::SwitchLabel[1]/following-sibling::BlockStatement) > 1
                              or (some $stmt (: in only the block statements until the next label :)
                                  in following-sibling::BlockStatement except following-sibling::SwitchLabel[1]/following-sibling::BlockStatement
                                  satisfies not($stmt/Statement/Block))]
                ]]></expr>
            <property-defs>
               <property-def name="checkIfElseStmt">
                  <type>Boolean</type>
                  <description>Require that 'if ... else' statements use braces</description>
                  <default-value>
                     <value>true</value>
                  </default-value>
               </property-def>
               <property-def name="checkSingleIfStmt">
                  <type>Boolean</type>
                  <description>Require that 'if' statements with a single branch use braces</description>
                  <default-value>
                     <value>true</value>
                  </default-value>
               </property-def>
               <property-def name="checkWhileStmt">
                  <type>Boolean</type>
                  <description>Require that 'while' loops use braces</description>
                  <default-value>
                     <value>true</value>
                  </default-value>
               </property-def>
               <property-def name="checkForStmt">
                  <type>Boolean</type>
                  <description>Require that 'for' loops should use braces</description>
                  <default-value>
                     <value>true</value>
                  </default-value>
               </property-def>
               <property-def name="checkDoWhileStmt">
                  <type>Boolean</type>
                  <description>Require that 'do ... while' loops use braces</description>
                  <default-value>
                     <value>true</value>
                  </default-value>
               </property-def>
               <property-def name="checkCaseStmt">
                  <type>Boolean</type>
                  <description>Require that cases of a switch have braces</description>
                  <default-value>
                     <value>false</value>
                  </default-value>
               </property-def>
               <property-def name="allowEmptyLoop">
                  <type>Boolean</type>
                  <description>Allow loops with an empty statement, e.g. 'while(true);'</description>
                  <default-value>
                     <value>false</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
while (true)    // not recommended
  x++;

while (true) {  // preferred approach
  x++;
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="DefaultPackage">
      <message>Use explicit scoping instead of the default package private level</message>
      <description>
            Use explicit scoping instead of accidental usage of default package private level.
            The rule allows methods and fields annotated with Guava's @VisibleForTesting.
        </description>
      <since>3.4</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration[@Interface= false()]
/ClassOrInterfaceBody
/ClassOrInterfaceBodyDeclaration
[not(Annotation//Name[ends-with(@Image, 'VisibleForTesting')])]
[
FieldDeclaration[@PackagePrivate= true()]
or MethodDeclaration[@PackagePrivate= true()]
]

                ]]></expr>
         </xpath>
      </impl>
   </rule-def>

    <rule-def name="DontImportJavaLang">
      <message>Avoid importing anything from the package 'java.lang'</message>
      <description>
            Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
        </description>
      <since>0.5</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.DontImportJavaLangRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
import java.lang.String;    // this is unnecessary

public class Foo {}

// --- in another source code file...

import java.lang.*;         // this is bad

public class Foo {}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="DuplicateImports">
      <message>Avoid duplicate imports such as ''{0}''</message>
      <description>
            Duplicate or overlapping import statements should be avoided.
        </description>
      <since>0.5</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.DuplicateImportsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
import java.lang.String;
import java.lang.*;
public class Foo {}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="EmptyMethodInAbstractClassShouldBeAbstract">
      <message>An empty method in an abstract class should be abstract instead</message>
      <description>
            Empty or auto-generated methods in an abstract class should be tagged as abstract. This helps to remove their inapproprate
            usage by developers who should be implementing their own versions in the concrete subclasses.
        </description>
      <since>4.1</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration[@Abstract = true()]
    /ClassOrInterfaceBody
    /ClassOrInterfaceBodyDeclaration
    /MethodDeclaration[@Abstract = false() and @Native = false()]
    [
        ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral) = true() )
        or
        ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image = '0']) = true() )
        or
        ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) = 2]) = true() )
        or
        (./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/EmptyStatement)
        or
        ( not (./Block/*) )
    ]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public abstract class ShouldBeAbstract {
    public Object couldBeAbstract() {
        // Should be abstract method ?
        return null;
    }

    public void couldBeAbstract() {
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ExtendsObject">
      <message>No need to explicitly extend Object.</message>
      <description>No need to explicitly extend Object.</description>
      <since>5.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[//ExtendsList/ClassOrInterfaceType[@Image='Object' or @Image='java.lang.Object']]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo extends Object {     // not required
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="FieldDeclarationsShouldBeAtStartOfClass">
      <message>Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.</message>
      <description>
            Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.
        </description>
      <since>5.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.FieldDeclarationsShouldBeAtStartOfClassRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class HelloWorldBean {

  // Field declared before methods / inner classes - OK
  private String _thing;

  public String getMessage() {
    return "Hello World!";
  }

  // Field declared after methods / inner classes - avoid this
  private String _fieldInWrongLocation;
}

        ]]></example>
      </examples>
   </rule-def>


    <rule-def name="FieldNamingConventions">
      <message>The {0} name ''{1}'' doesn''t match ''{2}''</message>
      <description>
            Configurable naming conventions for field declarations. This rule reports variable declarations
            which do not match the regex that applies to their specific kind ---e.g. constants (static final),
            enum constant, final field. Each regex can be configured through properties.

            By default this rule uses the standard Java naming convention (Camel case), and uses the ALL_UPPER
            convention for constants and enum constants.
        </description>
      <since>6.7.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.FieldNamingConventionsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
            class Foo {
                int myField = 1; // This is in camel case, so it's ok
                int my_Field = 1; // This contains an underscore, it's not ok by default
                                  // but you may allow it, or even require the "my_" prefix

                final int FinalField = 1; // you may configure a different convention for final fields,
                                          // e.g. here PascalCase: [A-Z][a-zA-Z0-9]*

                interface Interface {
                    double PI = 3.14; // interface "fields" use the constantPattern property
                }

                enum AnEnum {
                    ORG, NET, COM; // These use a separate property but are set to ALL_UPPER by default
                }
            }
            
        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ForLoopShouldBeWhileLoop">
      <message>This for loop could be simplified to a while loop</message>
      <description>
            Some for loops can be simplified to while loops, this makes them more concise.
        </description>
      <since>1.02</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ForStatement
  [not(LocalVariableDeclaration)]
  [not(ForInit)]
  [not(ForUpdate)]
  [Expression]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
    void bar() {
        for (;true;) true; // No Init or Update part, may as well be: while (true)
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="FormalParameterNamingConventions">
      <message>The {0} name ''{1}'' doesn''t match ''{2}''</message>
      <description>
            Configurable naming conventions for formal parameters of methods and lambdas.
            This rule reports formal parameters which do not match the regex that applies to their
            specific kind (e.g. lambda parameter, or final formal parameter). Each regex can be
            configured through properties.

            By default this rule uses the standard Java naming convention (Camel case).
        </description>
      <since>6.6.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.FormalParameterNamingConventionsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
            class Foo {

                abstract void bar(int myInt); // This is Camel case, so it's ok

                void bar(int my_i) { // this will be reported

                }

                void lambdas() {

                    // lambdas parameters can be configured separately
                    Consumer<String> lambda1 = s_str -> { };

                    // lambda parameters with an explicit type can be configured separately
                    Consumer<String> lambda1 = (String str) -> { };

                }

            }
            
        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="GenericsNaming">
      <message>Generics names should be a one letter long and upper case.</message>
      <description>
            Names for references to generic values should be limited to a single uppercase letter.
        </description>
      <since>4.2.6</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//TypeDeclaration/ClassOrInterfaceDeclaration/TypeParameters/TypeParameter[
  string-length(@Image) > 1
  or
  upper-case(@Image) != @Image
]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public interface GenericDao<E extends BaseModel, K extends Serializable> extends BaseDao {
    // This is ok...
}

public interface GenericDao<E extends BaseModel, K extends Serializable> {
    // Also this
}

public interface GenericDao<e extends BaseModel, K extends Serializable> {
    // 'e' should be an 'E'
}

public interface GenericDao<EF extends BaseModel, K extends Serializable> {
   // 'EF' is not ok.
}

        ]]></example>
      </examples>
   </rule-def>


    <rule-def name="IdenticalCatchBranches">
      <message>''catch'' branch identical to ''{0}'' branch</message>
      <description>
            Identical `catch` branches use up vertical space and increase the complexity of code without
            adding functionality. It's better style to collapse identical branches into a single multi-catch
            branch.
        </description>
      <since>6.4.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.IdenticalCatchBranchesRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
try {
    // do something
} catch (IllegalArgumentException e) {
    throw e;
} catch (IllegalStateException e) { // Can be collapsed into the previous block
    throw e;
}

try {
    // do something
} catch (IllegalArgumentException | IllegalStateException e) { // This is better
    throw e;
}
            
        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="LinguisticNaming">
      <message>Linguistics Antipattern - Method name and return type is inconsistent linguistically</message>
      <description>
            This rule finds Linguistic Naming Antipatterns. It checks for fields, that are named, as if they should
            be boolean but have a different type. It also checks for methods, that according to their name, should
            return a boolean, but don't. Further, it checks, that getters return something and setters won't.
            Finally, it checks that methods, that start with "to" - so called transform methods - actually return
            something, since according to their name, they should convert or transform one object into another.
            There is additionally an option, to check for methods that contain "To" in their name - which are
            also transform methods. However, this is disabled by default, since this detection is prone to
            false positives.

            For more information, see [Linguistic Antipatterns - What They Are and How
            Developers Perceive Them](https://doi.org/10.1007/s10664-014-9350-8).
        </description>
      <since>6.7.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.LinguisticNamingRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class LinguisticNaming {
    int isValid;    // the field name indicates a boolean, but it is an int.
    boolean isTrue; // correct type of the field

    void myMethod() {
        int hasMoneyLocal;      // the local variable name indicates a boolean, but it is an int.
        boolean hasSalaryLocal; // correct naming and type
    }

    // the name of the method indicates, it is a boolean, but the method returns an int.
    int isValid() {
        return 1;
    }
    // correct naming and return type
    boolean isSmall() {
        return true;
    }

    // the name indicates, this is a setter, but it returns something
    int setName() {
        return 1;
    }

    // the name indicates, this is a getter, but it doesn't return anything
    void getName() {
        // nothing to return?
    }

    // the name indicates, it transforms an object and should return the result
    void toDataType() {
        // nothing to return?
    }
    // the name indicates, it transforms an object and should return the result
    void grapeToWine() {
        // nothing to return?
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="LocalHomeNamingConvention">
      <message>The Local Home interface of a Session EJB should be suffixed by 'LocalHome'</message>
      <description>
            The Local Home interface of a Session EJB should be suffixed by 'LocalHome'.
        </description>
      <since>4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration
[
    (
        (./ExtendsList/ClassOrInterfaceType[ends-with(@Image,'EJBLocalHome')])
    )
    and
    not
    (
        ends-with(@SimpleName,'LocalHome')
    )
]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public interface MyBeautifulLocalHome extends javax.ejb.EJBLocalHome {} // proper name

public interface MissingProperSuffix extends javax.ejb.EJBLocalHome {}  // non-standard name

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="LocalInterfaceSessionNamingConvention">
      <message>The Local Interface of a Session EJB should be suffixed by 'Local'</message>
      <description>
            The Local Interface of a Session EJB should be suffixed by 'Local'.
        </description>
      <since>4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration
[
    (
        (./ExtendsList/ClassOrInterfaceType[ends-with(@Image,'EJBLocalObject')])
    )
    and
    not
    (
        ends-with(@SimpleName,'Local')
    )
]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public interface MyLocal extends javax.ejb.EJBLocalObject {}                // proper name

public interface MissingProperSuffix extends javax.ejb.EJBLocalObject {}    // non-standard name

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="LocalVariableCouldBeFinal">
      <message>Local variable ''{0}'' could be declared final</message>
      <description>
            A local variable assigned only once can be declared final.
        </description>
      <since>2.2</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.LocalVariableCouldBeFinalRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Bar {
    public void foo () {
    String txtA = "a";          // if txtA will not be assigned again it is better to do this:
    final String txtB = "b";
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="LocalVariableNamingConventions">
      <message>The {0} name ''{1}'' doesn''t match ''{2}''</message>
      <description>
            Configurable naming conventions for local variable declarations and other locally-scoped
            variables. This rule reports variable declarations which do not match the regex that applies to their
            specific kind (e.g. final variable, or catch-clause parameter). Each regex can be configured through
            properties.

            By default this rule uses the standard Java naming convention (Camel case).
        </description>
      <since>6.6.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.LocalVariableNamingConventionsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
            class Foo {
                void bar() {
                    int localVariable = 1; // This is in camel case, so it's ok
                    int local_variable = 1; // This will be reported unless you change the regex

                    final int i_var = 1; // final local variables can be configured separately

                    try {
                        foo();
                    } catch (IllegalArgumentException e_illegal) {
                        // exception block parameters can be configured separately
                    }

                }
            }
            
        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="LongVariable">
      <message>Avoid excessively long variable names like {0}</message>
      <description>
            Fields, formal arguments, or local variable names that are too long can make the code difficult to follow.
        </description>
      <since>0.3</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[//VariableDeclaratorId[string-length(@Name) > $minimum]]]></expr>
            <property-defs>
               <property-def name="minimum">
                  <type>Integer</type>
                  <description>The variable length reporting threshold</description>
                  <default-value>
                     <value>17</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Something {
    int reallyLongIntName = -3;             // VIOLATION - Field
    public static void main( String argumentsList[] ) { // VIOLATION - Formal
        int otherReallyLongName = -5;       // VIOLATION - Local
        for (int interestingIntIndex = 0;   // VIOLATION - For
             interestingIntIndex < 10;
             interestingIntIndex ++ ) {
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="MDBAndSessionBeanNamingConvention">
      <message>SessionBean or MessageBean should be suffixed by Bean</message>
      <description>
            The EJB Specification states that any MessageDrivenBean or SessionBean should be suffixed by 'Bean'.
        </description>
      <since>4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//TypeDeclaration/ClassOrInterfaceDeclaration
[
    (
        (./ImplementsList/ClassOrInterfaceType[ends-with(@Image,'SessionBean')])
        or
        (./ImplementsList/ClassOrInterfaceType[ends-with(@Image,'MessageDrivenBean')])
    )
    and
    not
    (
        ends-with(@SimpleName,'Bean')
    )
]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class SomeBean implements SessionBean{}                  // proper name

public class MissingTheProperSuffix implements SessionBean {}   // non-standard name

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="MethodArgumentCouldBeFinal">
      <message>Parameter ''{0}'' is not assigned and could be declared final</message>
      <description>
            A method argument that is never re-assigned within the method can be declared final.
        </description>
      <since>2.2</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.MethodArgumentCouldBeFinalRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public void foo1 (String param) {       // do stuff with param never assigning it

}

public void foo2 (final String param) { // better, do stuff with param never assigning it

}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="MethodNamingConventions">
      <message>The {0} name ''{1}'' doesn''t match ''{2}''</message>
      <description>
            Configurable naming conventions for method declarations. This rule reports
            method declarations which do not match the regex that applies to their
            specific kind (e.g. JUnit test or native method). Each regex can be
            configured through properties.

            By default this rule uses the standard Java naming convention (Camel case).
        </description>
      <since>1.2</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.MethodNamingConventionsRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
    public void fooStuff() {
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="NoPackage">
      <message>All classes, interfaces, enums and annotations must belong to a named package</message>
      <description>
            Detects when a class, interface, enum or annotation does not have a package definition.
        </description>
      <since>3.3</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[/CompilationUnit[not(./PackageDeclaration)]/TypeDeclaration[1]]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
// no package declaration
public class ClassInDefaultPackage {
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UseUnderscoresInNumericLiterals">
      <message>Number {0} should separate every third digit with an underscore</message>
      <description>
            Since Java 1.7, numeric literals can use underscores to separate digits. This rule enforces that
            numeric literals above a certain length use these underscores to increase readability.

            The rule only supports decimal (base 10) literals for now. The acceptable length under which literals
            are not required to have underscores is configurable via a property. Even under that length, underscores
            that are misplaced (not making groups of 3 digits) are reported.
        </description>
      <since>6.10.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//Literal[
     @IntLiteral = true()
  or @LongLiteral = true()
  or @DoubleLiteral = true()
  or @FloatLiteral = true()
]
 (: Filter out literals in base other than 10 :)
 [not(matches(@Image, "^0[^.]"))]
 (: Filter out ignored field name :)
 [not(ancestor::VariableDeclarator[1][@Name = 'serialVersionUID'])]
 [
   some $num in tokenize(@Image, "[dDfFlLeE+\-]")
   satisfies not(
                  ( contains($num, ".")
                    and string-length(substring-before($num, ".")) <= $acceptableDecimalLength
                    and string-length(substring-after($num, ".")) <= $acceptableDecimalLength
                    or string-length($num) <= $acceptableDecimalLength
                  )
                  and not(contains($num,"_"))
                  or matches($num, "^[0-9]{1,3}(_[0-9]{3})*(\.([0-9]{3}_)*[0-9]{1,3})?$")
                )
 ]

                ]]></expr>
            <property-defs>
               <property-def name="acceptableDecimalLength">
                  <type>Integer</type>
                  <description>Length under which literals in base 10 are not required to have underscores</description>
                  <default-value>
                     <value>4</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
    private int num = 1000000; // should be 1_000_000
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="OnlyOneReturn">
      <message>A method should have only one exit point, and that should be the last statement in the method</message>
      <description>
            A method should have only one exit point, and that should be the last statement in the method.
        </description>
      <since>1.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.OnlyOneReturnRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class OneReturnOnly1 {
  public void foo(int x) {
    if (x > 0) {
      return "hey";   // first exit
    }
    return "hi";    // second exit
  }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="PackageCase">
      <message>Package name contains upper case characters</message>
      <description>
            Detects when a package definition contains uppercase characters.
        </description>
      <since>3.3</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[//PackageDeclaration/Name[lower-case(@Image)!=@Image]]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
package com.MyCompany;  // should be lowercase name

public class SomeClass {
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="PrematureDeclaration">
      <message>Avoid declaring a variable if it is unreferenced before a possible exit point.</message>
      <description>
            Checks for variables that are defined before they might be used. A reference is deemed to be premature if it is created right before a block of code that doesn't use it that also has the ability to return or throw an exception.
        </description>
      <since>5.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.PrematureDeclarationRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public int getLength(String[] strings) {

    int length = 0; // declared prematurely

    if (strings == null || strings.length == 0) return 0;

    for (String str : strings) {
        length += str.length();
    }

    return length;
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="RemoteInterfaceNamingConvention">
      <message>Remote Interface of a Session EJB should NOT be suffixed</message>
      <description>
            Remote Interface of a Session EJB should not have a suffix.
        </description>
      <since>4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration
[
    (
        (./ExtendsList/ClassOrInterfaceType[ends-with(@Image,'EJBObject')])
    )
    and
    (
        ends-with(@SimpleName,'Session')
        or
        ends-with(@SimpleName,'EJB')
        or
        ends-with(@SimpleName,'Bean')
    )
]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
/* Poor Session suffix */
public interface BadSuffixSession extends javax.ejb.EJBObject {}

/* Poor EJB suffix */
public interface BadSuffixEJB extends javax.ejb.EJBObject {}

/* Poor Bean suffix */
public interface BadSuffixBean extends javax.ejb.EJBObject {}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="RemoteSessionInterfaceNamingConvention">
      <message>Remote Home interface of a Session EJB should be suffixed by 'Home'</message>
      <description>
            A Remote Home interface type of a Session EJB should be suffixed by 'Home'.
        </description>
      <since>4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//ClassOrInterfaceDeclaration
[
    (
        (./ExtendsList/ClassOrInterfaceType[ends-with(@Image,'EJBHome')])
    )
    and
    not
    (
        ends-with(@SimpleName,'Home')
    )
]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public interface MyBeautifulHome extends javax.ejb.EJBHome {}       // proper name

public interface MissingProperSuffix extends javax.ejb.EJBHome {}   // non-standard name

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ShortClassName">
      <message>Avoid short class names like {0}</message>
      <description>
            Short Classnames with fewer than e.g. five characters are not recommended.
        </description>
      <since>5.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[//ClassOrInterfaceDeclaration[string-length(@SimpleName) < $minimum]]]></expr>
            <property-defs>
               <property-def name="minimum">
                  <type>Integer</type>
                  <description>Number of characters that are required as a minimum for a class name.</description>
                  <default-value>
                     <value>5</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ShortMethodName">
      <message>Avoid using short method names</message>
      <description>
            Method names that are very short are not helpful to the reader.
        </description>
      <since>0.3</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[//MethodDeclaration[string-length(@Name) < $minimum]]]></expr>
            <property-defs>
               <property-def name="minimum">
                  <type>Integer</type>
                  <description>Number of characters that are required as a minimum for a method name.</description>
                  <default-value>
                     <value>3</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class ShortMethod {
    public void a( int i ) { // Violation
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="ShortVariable">
      <message>Avoid variables with short names like {0}</message>
      <description>
            Fields, local variables, or parameter names that are very short are not helpful to the reader.
        </description>
      <since>0.3</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//VariableDeclaratorId[string-length(@Name) < $minimum]
 (: ForStatement :)
 [not(../../..[self::ForInit])]
 (: Foreach statement :)
 [not(../../..[self::ForStatement])]
 (: Catch statement parameter :)
 [not(../..[self::CatchStatement])]
 (: Lambda expression parameter :)
 [not(parent::LambdaExpression or ../../..[self::LambdaExpression])]

                ]]></expr>
            <property-defs>
               <property-def name="minimum">
                  <type>Integer</type>
                  <description>Number of characters that are required as a minimum for a variable name.</description>
                  <default-value>
                     <value>3</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Something {
    private int q = 15;                         // field - too short
    public static void main( String as[] ) {    // formal arg - too short
        int r = 20 + q;                         // local var - too short
        for (int i = 0; i < 10; i++) {          // not a violation (inside 'for' loop)
            r += q;
        }
        for (Integer i : numbers) {             // not a violation (inside 'for-each' loop)
            r += q;
        }
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="TooManyStaticImports">
      <message>Too many static imports may lead to messy code</message>
      <description>
            If you overuse the static import feature, it can make your program unreadable and
            unmaintainable, polluting its namespace with all the static members you import.
            Readers of your code (including you, a few months after you wrote it) will not know
            which class a static member comes from (Sun 1.5 Language Guide).
        </description>
      <since>4.1</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[.[count(ImportDeclaration[@Static = true()]) > $maximumStaticImports]]]></expr>
            <property-defs>
               <property-def name="maximumStaticImports">
                  <type>Integer</type>
                  <description>All static imports can be disallowed by setting this to 0</description>
                  <default-value>
                     <value>4</value>
                  </default-value>
               </property-def>
            </property-defs>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
import static Lennon;
import static Ringo;
import static George;
import static Paul;
import static Yoko; // Too much !

        ]]></example>
      </examples>
   </rule-def>


    <rule-def name="UnnecessaryAnnotationValueElement">
      <message>Avoid the use of value in annotations when it's the only element</message>
      <description>
            Avoid the use of value in annotations when it's the only element.
        </description>
      <since>6.2.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryAnnotationValueElementRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
@TestClassAnnotation(value = "TEST")
public class Foo {

    @TestMemberAnnotation(value = "TEST")
    private String y;

    @TestMethodAnnotation(value = "TEST")
    public void bar() {
        int x = 42;
        return;
    }
}

// should be

@TestClassAnnotation("TEST")
public class Foo {

    @TestMemberAnnotation("TEST")
    private String y;

    @TestMethodAnnotation("TEST")
    public void bar() {
        int x = 42;
        return;
    }
}


        ]]></example>
      </examples>
   </rule-def>


    <rule-def name="UnnecessaryConstructor">
      <message>Avoid unnecessary constructors - the compiler will generate these for you</message>
      <description>
            This rule detects when a constructor is not necessary; i.e., when there is only one constructor and the
            constructor is identical to the default constructor. The default constructor should has same access
            modifier as the declaring class. In an enum type, the default constructor is implicitly private.
        </description>
      <since>1.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryConstructorRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
  public Foo() {}
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UnnecessaryFullyQualifiedName">
      <message>Unnecessary use of fully qualified name ''{0}'' due to existing {2}import ''{1}''</message>
      <description>
            Import statements allow the use of non-fully qualified names.  The use of a fully qualified name
            which is covered by an import statement is redundant.  Consider using the non-fully qualified name.
        </description>
      <since>5.0</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryFullyQualifiedNameRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
import java.util.List;

public class Foo {
    private java.util.List list1;   // Unnecessary FQN
    private List list2;             // More appropriate given import of 'java.util.List'
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UnnecessaryLocalBeforeReturn">
      <message>Consider simply returning the value vs storing it in local variable ''{0}''</message>
      <description>
            Avoid the creation of unnecessary local variables
        </description>
      <since>3.3</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryLocalBeforeReturnRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
   public int foo() {
     int x = doSomething();
     return x;  // instead, just 'return doSomething();'
   }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UnnecessaryModifier">
      <message>Unnecessary modifier{0} on {1} ''{2}''{3}</message>
      <description>
            Fields in interfaces and annotations are automatically `public static final`, and methods are `public abstract`.
            Classes, interfaces or annotations nested in an interface or annotation are automatically `public static`
            (all nested interfaces and annotations are automatically static).
            Nested enums are automatically `static`.
            For historical reasons, modifiers which are implied by the context are accepted by the compiler, but are superfluous.
        </description>
      <since>1.02</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryModifierRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public @interface Annotation {
    public abstract void bar();     // both abstract and public are ignored by the compiler
    public static final int X = 0;  // public, static, and final all ignored
    public static class Bar {}      // public, static ignored
    public static interface Baz {}  // ditto
}
public interface Foo {
    public abstract void bar();     // both abstract and public are ignored by the compiler
    public static final int X = 0;  // public, static, and final all ignored
    public static class Bar {}      // public, static ignored
    public static interface Baz {}  // ditto
}
public class Bar {
    public static interface Baz {}  // static ignored
    public static enum FoorBar {    // static ignored
        FOO;
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UnnecessaryReturn">
      <message>Avoid unnecessary return statements</message>
      <description>
            Avoid the use of unnecessary return statements.
        </description>
      <since>1.3</since>
      <impl>
         <language id="java"/>
         <class>net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryReturnRule</class>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
    public void bar() {
        int x = 42;
        return;
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UseDiamondOperator">
      <message>Explicit type arguments can be replaced by Diamond Operator</message>
      <description>
            Use the diamond operator to let the type be inferred automatically. With the Diamond operator it is possible
            to avoid duplication of the type parameters.
            Instead, the compiler is now able to infer the parameter types for constructor calls,
            which makes the code also more readable.
        </description>
      <since>6.11.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
(
//VariableInitializer[preceding-sibling::VariableDeclaratorId[1]/@TypeInferred=false()]
|
//StatementExpression[AssignmentOperator and PrimaryExpression/PrimaryPrefix[not(Expression)]]
)
/Expression/PrimaryExpression[not(PrimarySuffix) and not(ancestor::ArgumentList)]
/PrimaryPrefix
/AllocationExpression
    [@AnonymousClass=false()]
    [ClassOrInterfaceType/TypeArguments[@Diamond=false() and not(TypeArgument//TypeArguments)]]
    [not(ArrayDimsAndInits)]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
List<String> strings = new ArrayList<String>(); // unnecessary duplication of type parameters
List<String> stringsWithDiamond = new ArrayList<>(); // using the diamond operator is more concise

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UselessParentheses">
      <message>Useless parentheses.</message>
      <description>Useless parentheses should be removed.</description>
      <since>5.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//Expression[not(parent::PrimaryPrefix)]/PrimaryExpression[count(*)>1]
  /PrimaryPrefix/Expression
    [not(./CastExpression)]
    [not(./ConditionalExpression)]
    [not(./AdditiveExpression)]
    [not(./AssignmentOperator)]
|
//Expression[not(parent::PrimaryPrefix)]/PrimaryExpression[count(*)=1]
  /PrimaryPrefix/Expression
|
//Expression/ConditionalAndExpression/PrimaryExpression/PrimaryPrefix/Expression[
    count(*)=1 and
    not(./CastExpression) and
    not(./EqualityExpression/MultiplicativeExpression) and
    not(./ConditionalExpression) and
    not(./ConditionalOrExpression)]
|
//Expression/ConditionalOrExpression/PrimaryExpression/PrimaryPrefix/Expression[
    count(*)=1 and
    not(./CastExpression) and
    not(./ConditionalExpression) and
    not(./EqualityExpression/MultiplicativeExpression)]
|
//Expression/ConditionalExpression/PrimaryExpression/PrimaryPrefix/Expression[
    count(*)=1 and
    not(./CastExpression) and
    not(./EqualityExpression)]
|
//Expression/AdditiveExpression[not(./PrimaryExpression/PrimaryPrefix/Literal[@StringLiteral= true()])]
  /PrimaryExpression[1]/PrimaryPrefix/Expression[
    count(*)=1 and
    not(./CastExpression) and
    not(./AdditiveExpression[@Operator = '-']) and
    not(./ShiftExpression) and
    not(./RelationalExpression) and
    not(./InstanceOfExpression) and
    not(./EqualityExpression) and
    not(./AndExpression) and
    not(./ExclusiveOrExpression) and
    not(./InclusiveOrExpression) and
    not(./ConditionalAndExpression) and
    not(./ConditionalOrExpression) and
    not(./ConditionalExpression)]
|
//Expression/EqualityExpression/PrimaryExpression/PrimaryPrefix/Expression[
    count(*)=1 and
    not(./CastExpression) and
    not(./AndExpression) and
    not(./InclusiveOrExpression) and
    not(./ExclusiveOrExpression) and
    not(./ConditionalExpression) and
    not(./ConditionalAndExpression) and
    not(./ConditionalOrExpression) and
    not(./EqualityExpression)]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {

    private int _bar1;
    private Integer _bar2;

    public void setBar(int n) {
        _bar1 = Integer.valueOf((n)); // here
        _bar2 = (n); // and here
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UselessQualifiedThis">
      <message>Useless qualified this usage in the same class.</message>
      <description>
            Reports qualified this usages in the same class.
        </description>
      <since>5.4.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
                    
//PrimaryExpression
[PrimaryPrefix/Name[@Image]]
[PrimarySuffix[@Arguments= false() and @ArrayDereference = false()]]
[not(PrimarySuffix/MemberSelector)]
[ancestor::ClassOrInterfaceBodyDeclaration[1][@AnonymousInnerClass= false()]]
/PrimaryPrefix/Name[@Image = ancestor::ClassOrInterfaceDeclaration[1]/@SimpleName]

                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
public class Foo {
    final Foo otherFoo = Foo.this;  // use "this" directly

    public void doSomething() {
         final Foo anotherFoo = Foo.this;  // use "this" directly
    }

    private ActionListener returnListener() {
        return new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                doSomethingWithQualifiedThis(Foo.this);  // This is fine
            }
        };
    }

    private class Foo3 {
        final Foo myFoo = Foo.this;  // This is fine
    }

    private class Foo2 {
        final Foo2 myFoo2 = Foo2.this;  // Use "this" direclty
    }
}

        ]]></example>
      </examples>
   </rule-def>

    <rule-def name="UseShortArrayInitializer">
      <message>Array initialization can be written shorter</message>
      <description>

            When declaring and initializing array fields or variables, it is not necessary to explicitly create a new array
            using `new`. Instead one can simply define the initial content of the array as a expression in curly braces.

            E.g. `int[] x = new int[] { 1, 2, 3 };` can be written as `int[] x = { 1, 2, 3 };`.
            
        </description>
      <since>6.15.0</since>
      <impl>
         <language id="java"/>
         <xpath>
            <expr><![CDATA[
//VariableDeclarator
    [VariableDeclaratorId[@ArrayType = true() and @TypeInferred = false()]]
    [VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ArrayDimsAndInits/ArrayInitializer]
                ]]></expr>
         </xpath>
      </impl>
      <examples>
         <example><![CDATA[
            
Foo[] x = new Foo[] { ... }; // Overly verbose
Foo[] x = { ... }; //Equivalent to above line

        ]]></example>
      </examples>
   </rule-def>
</ruleset>
