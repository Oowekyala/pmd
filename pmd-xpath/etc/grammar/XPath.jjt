
options {
  JAVA_UNICODE_ESCAPE = true;

  CACHE_TOKENS = true;
  STATIC = false;
  USER_CHAR_STREAM = true;
  JDK_VERSION = "1.6";

  MULTI = true;
  VISITOR = true;
  NODE_USES_PARSER = true;
  TRACK_TOKENS = true;
  NODE_PACKAGE = "net.sourceforge.pmd.lang.xpath.ast";

   DEBUG_PARSER = true;
   DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(XPathParser)

import net.sourceforge.pmd.lang.ast.CharStream;

public class XPathParser {

    void throwParseException(String message) {
        ParseException exc = generateParseException();
        throw new ParseException(exc.getMessage() + message);
    }


    void checkVarBinding(boolean isLetContext, boolean wasLetFound) {
        String expected = isLetContext ? ":=" : "in";
        String actual = wasLetFound ? ":=" : "in";

        if (isLetContext != wasLetFound) {
          throwParseException("Variable binding expected '" + expected + "', actual '" + actual);
        }
    }

}
PARSER_END(XPathParser)

TOKEN_MGR_DECLS :
{
    private int commentNestingDepth = 0;
}

/* WHITE SPACE */

SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* COMMENTS */

SKIP : { <"(:"> { commentNestingDepth = 1; } : COMMENT_STATE }

// Comments may be nested
< COMMENT_STATE >  SKIP : {  "(:" { commentNestingDepth++; } }
< COMMENT_STATE >  SKIP : {  ":)" { SwitchTo(--commentNestingDepth == 0 ? DEFAULT : COMMENT_STATE); } }
< COMMENT_STATE >  SKIP : {  < ~[] > }


/* LITERALS */


TOKEN :
{
  < STRING_LITERAL: "\"" ("\"\"" | ~["\""])* "\"" | "'" ("''" | ~["'"])* "'" >
| < BRACED_URI_LITERAL: "Q" "{" (~["{", "}"])* "}" >

| < INTEGER_LITERAL: <DIGITS> >
| < DECIMAL_LITERAL: "." <DIGITS> | <DIGITS> "." <MAYBE_DIGITS> >
| < DOUBLE_LITERAL: ("." <DIGITS> | <DIGITS> ("." <MAYBE_DIGITS>)?) <EXPONENT> >

| < #DIGITS: (["0"-"9"])+ >
| < #MAYBE_DIGITS: (["0"-"9"])* >
| < #EXPONENT: ["e","E"] (["+","-"])? <DIGITS> >
}


/* RESERVED WORDS */

TOKEN :
{
// Axes
  < SELF: "self" >
| < CHILD: "child" >
| < ATTRIBUTE: "attribute" >
| < DESCENDANT: "descendant" >
| < DESCENDANT_OR_SELF: "descendant-or-self" >
| < ANCESTOR: "ancestor" >
| < ANCESTOR_OR_SELF: "ancestor-or-self" >
| < FOLLOWING: "following" >
| < FOLLOWING_SIBLING: "following-sibling" >
| < NAMESPACE: "namespace" >
| < PARENT: "parent" >
| < PRECEDING: "preceding" >
| < PRECEDING_SIBLING: "preceding-sibling" >

// Operators
| < OR: "or" >
| < AND: "and" >
// "not" is a function
| < DIV: "div" >
| < IDIV: "idiv" >
| < MOD: "mod" >
| < DOUBLE_PIPE: "||" >
| < PIPE: "|" >
| < UNION: "union" >
| < INTERSECT: "intersect" >
| < EXCEPT: "except" >
| < MINUS: "-" >
| < BANG: "!" >
| < PATH: "/" >
| < PATH_ALT: "//" >

// Comparison operators
| < NE: "ne" >
| < EQ: "eq" >
| < LT: "lt" >
| < LE: "le" >
| < GT: "gt" >
| < GE: "ge" >
| < COMP: "=" | "!=" | "<" | "<=" | ">" | ">=" | ">>" | "<<" >


// Keywords
| < SOME: "some" >
| < IN: "in" >
| < SATISFIES: "satisfies" >
| < AS: "as" >
| < IS: "is" >
| < FOR: "for" >
| < EVERY: "every" >
| < CAST: "cast" >
| < CASTABLE: "castable" >
| < TREAT: "treat" >
| < INSTANCE: "instance" >
| < OF: "of" >
| < TO: "to" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < RETURN: "return" >
| < LET: "let" >
| < EMPTY_SEQUENCE: "empty-sequence" >
| < ITEM: "item" >


// Node kinds
| < NODE: "node" >
| < DOCUMENT_NODE: "document-node" >
| < TEXT: "text" >
| < COMMENT: "comment" >
| < NAMESPACE_NODE: "namespace-node" >
| < PROCESSING_INSTRUCTION: "processing-instruction" >
// | < ATTRIBUTE: "attribute" > // also a node kind, but already defined
| < SCHEMA_ATTRIBUTE: "schema-attribute" >
| < ELEMENT: "element" >
| < SCHEMA_ELEMENT: "schema-element" >
| < FUNCTION: "function" >

// Separators
| < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < LCURLY: "{" >
| < RCURLY: "}" >
| < SEMICOLON: ";" >
| < DOUBLE_COLON: "::" >
| < DOUBLE_PERIOD: ".." >
| < COMMA: "," >
| < LET_ASSIGN: ":=" >
| < PERIOD: "." >
| < AT: "@" >
| < POUND: "#" >
| < QUESTION_MARK: "?" >
| < STAR: "*" >
| < PLUS: "+" >
| < DOLLAR: "$" >
| < COLON: ":" >
}




/* NAMES */

TOKEN :
{
  < EQNAME: <NCNAME> (":" <NCNAME>)? | <BRACED_URI_LITERAL> <NCNAME> >
|
  // The actual lexical grammar for NCName is: any name except <CHAR>* ":" <CHAR>*
  < NCNAME: <NAME_START_CHAR_NO_COLON> (<NAME_CHAR_NO_COLON>)* >
|
  < #NAME_START_CHAR_NO_COLON: [
    "A"-"Z",
    "a"-"z",
    "_",
    "\u00c0"-"\u00d6",
    "\u00d8"-"\u00f6",
    "\u00f8"-"\u02ff",
    "\u0370"-"\u037d",
    "\u037f"-"\u1fff",
    "\u200c"-"\u200d",
    "\u2070"-"\u218f",
    "\u2c00"-"\u2fef",
    "\u3001"-"\ud7ff",
    "\uf900"-"\ufdcf",
    "\ufdf0"-"\ufffd",
    "\u1000"-"\uefff"
  ] >
|
  < #NAME_CHAR_NO_COLON: <NAME_START_CHAR_NO_COLON> | [
  "-",
  ".",
  "0"-"9",
  "\u00b7",
  "\u0300"-"\u036f",
  "\u203f"-"\u2040"
  ] >
}


/*****************************************
 * THE XPATH LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

ASTXPathRoot XPathRoot() :
{}
{
  Expr() <EOF> { return jjtThis; }
}

void Expr() :
{}
{
  VoidSingleExpr() ("," VoidSingleExpr() )*
}

// This is a shorthand for "An Expr with necessarily one child"
void ExprSingle() #Expr:
{}
{
    VoidSingleExpr()
}

// This factorises the two
void VoidSingleExpr() #void:
{}
{
    ForExpr()
  | LetExpr()
  | QuantifiedExpr()
  | IfExpr()
  | OrExpr()
}



void ForExpr():
{}
{
 <FOR> VarBindingList(false) <RETURN> ExprSingle()
}

void LetExpr():
{}
{
 <LET> VarBindingList(true) <RETURN> ExprSingle()
}

void QuantifiedExpr():
{}
{
  (<SOME> { jjtThis.setUniversallyQuantified(false); }| <EVERY> {jjtThis.setUniversallyQuantified(true);})
  VarBindingList(false)
  <SATISFIES> ExprSingle()
}

void VarBindingList(boolean isLetCtx):
{}
{
    VarBinding(isLetCtx) ("," VarBinding(isLetCtx))*
}



void VarBinding(boolean isLet):
{}
{
  "$" VarName() { jjtThis.setVarName(token.getImage()); }
  (<IN> {checkVarBinding(isLet, false);} | ":=" {checkVarBinding(isLet, true);})
  ExprSingle()
}

void IfExpr():
{}
{
  <IF> "(" Expr() ")" <THEN> ExprSingle() <ELSE> ExprSingle()
}

void OrExpr() #OrExpr(>1):
{}
{
  AndExpr() ( <OR> AndExpr() )*
}

void AndExpr() #AndExpr(>1):
{}
{
  ComparisonExpr() ( <AND> ComparisonExpr() )*
}

void ComparisonExpr() #ComparisonExpr(>1):
{String operator = null;}
{
  StringConcatExpr()
  (
    (operator = ComparisonOperator()) StringConcatExpr() {jjtThis.setOperator(operator);}
  )?
}

String ComparisonOperator() #void: // TODO store operator, do that in the Java node
{}
{
   ( <COMP> | <NE> | <EQ> | <LT> | <LE> | <GT> | <GE> )
   { return token.getImage(); }
}



void StringConcatExpr() #StringConcatExpr(>1):
{}
{
  RangeExpr() ( "||" RangeExpr() )*
}

void RangeExpr() #RangeExpr(>1):
{}
{
  AdditiveExpr() ( <TO> AdditiveExpr() )?
}

// In the following, we use nodes to represent the operators because there may be several expressions chained.
// e.g. E1 + E2 - E3 ~> E1 PlusOperator E2 MinusOperator E3

void AdditiveExpr() #AdditiveExpr(>1):
{}
{
  MultiplicativeExpr() ( ( "+" #PlusOperator | "-" #MinusOperator) MultiplicativeExpr() )*
}

void MultiplicativeExpr() #MultiplicativeExpr(>1):
{}
{
  UnionExpr()
  (
    (   <STAR> #TimesOperator
      | <DIV> #DivOperator
      | <IDIV> #IDivOperator
      | <MOD> #ModOperator
    )

    UnionExpr()
  )*
}

void UnionExpr() #UnionExpr(>1):
{}
{
  IntersectExceptExpr() ( UnionOperator() IntersectExceptExpr() )*
}

void UnionOperator():
{}
{
    <UNION>
  | "|" { jjtThis.setShorthand(true); }
}

void IntersectExceptExpr() #IntersectExceptExpr(>1):
{}
{
  InstanceofExpr()
  (
    (
        <INTERSECT> #IntersectOperator
      | <EXCEPT> #ExceptOperator
    )

    InstanceofExpr()
  )*
}


void InstanceofExpr() #InstanceofExpr(>1):
{}
{
  TreatExpr() ( <INSTANCE> <OF> SequenceType() )?
}

void TreatExpr() #TreatExpr(>1):
{}
{
  CastableExpr() ( <TREAT> <AS> SequenceType() )?
}

void CastableExpr() #CastableExpr(>1):
{}
{
  CastExpr() ( LOOKAHEAD (3) <TREAT> <AS> SingleType() )?
}

void CastExpr() #CastExpr(>1):
{}
{
  UnaryExpr() ( <CAST> <AS> SingleType() )?
}

void UnaryExpr() #UnaryExpr(push):
{ boolean push = false; }
{
      [ < ([ "+" , "-" ])+ > { push = true; } ] MapExpr()
}

void MapExpr() #MapExpr(>1) :
{}
{
 PathExpr() ( "!" PathExpr() )*
}

/* PATH EXPRESSIONS */

// Trivial expressions are pruned with the "trivial" parameter passing
// to remove the PathExpr context
// See documentation on ASTPathExpr
void PathExpr() #PathExpr(!trivial):
{ boolean trivial = false; }
{
    ("/" [ RelativePathExpr(false) ])                    { jjtThis.setRootAnchor(); }
  | ( "//" RelativePathExpr(false))                      { jjtThis.setDescendantAnchor(); }
  | (trivial = RelativePathExpr(true))                   { jjtThis.setRelativeAnchor(); }
}

// Returns whether the step is trivial
boolean RelativePathExpr(boolean maybeTrivial) #void:
{}
{
  (maybeTrivial = StepExpr(maybeTrivial))
  (
    ( "/" | AbbrevPathOperator()) // "//" is synthesized as a StepExpr for consistency
    StepExpr(false)
    { maybeTrivial = false; }
  )*
  { return maybeTrivial; }
}


void AbbrevPathOperator() #StepExpr: // Pushes a step expr
{}
{
    "//" { jjtThis.setAbbrevDescendantOrSelf();} // this function synthesizes a NodeTest
}

// Returns whether the step is trivial
boolean StepExpr(boolean maybeTrivial) #StepExpr(!maybeTrivial):
{}
{
    (//LOOKAHEAD(2) // Lookahead because <EQNAME> may start an ExactNameTest or e.g. a function call
      (AxisStep() {maybeTrivial = false;}) | PostfixExpr()
    )
    { return maybeTrivial; }
}

ASTAxisStep AxisStep():
{}
{
 (LOOKAHEAD(1) // "attribute" may start an axis or a kind test
               // We don't look ahead and let the parser backtrack since if "::" is not present
               // it only backtracks one token
   (jjtThis.axis = Axis()) "::" NodeTest()
 |
 // The nodetest is #void, distinctions are implemented with an interface
   NodeTest()       { jjtThis.setAbbrevNoAxis(); }
 |
   "@" NodeTest()   { jjtThis.setAbbrevAttributeAxis(); }
 |
   ".."             { jjtThis.setAbbrevParentNodeTest();  }
 )
 PredicateList()
 { return jjtThis; }
}

// Only the AxisStep is pushed on the stack

Axis Axis() #void:
{
  // It's a child if this production only matches the NodeTest
  Axis axis = null;
}
{
    ( <SELF> { axis = Axis.SELF;}
    | <CHILD> { axis = Axis.CHILD; }
    | <ATTRIBUTE> { axis = Axis.ATTRIBUTE; }
    | <DESCENDANT> { axis = Axis.DESCENDANT; }
    | <DESCENDANT_OR_SELF> { axis = Axis.DESCENDANT_OR_SELF; }
    | <FOLLOWING> { axis = Axis.FOLLOWING; }
    | <FOLLOWING_SIBLING> { axis = Axis.FOLLOWING_SIBLING; }
    | <NAMESPACE> { axis = Axis.NAMESPACE; }
    | <PARENT> { axis = Axis.PARENT; }
    | <ANCESTOR> { axis = Axis.ANCESTOR; }
    | <ANCESTOR_OR_SELF> { axis = Axis.ANCESTOR_OR_SELF; }
    | <PRECEDING_SIBLING> { axis = Axis.PRECEDING_SIBLING; }
    | <PRECEDING> { axis = Axis.PRECEDING; }
    )
    { return axis; }
}

NodeTest NodeTest() #void:
{}
{
    (KindTest() | NameTest()) // both of these are #void
    { return (NodeTest) jjtree.peekNode(); } // Returns the last node to have been pushed
}

void NameTest() #void:
{}
{
   ExactNameTest() | WildcardNameTest()
}

void ExactNameTest():
{}
{
    EQName()
}

void WildcardNameTest():
{}
{
      "*" [ ":" NCName() {jjtThis.setPrefixWildcard();} ]
    | NCName() ":" "*" {jjtThis.setLocalNameWildcard();}
    | <BRACED_URI_LITERAL> "*" {jjtThis.setLocalNameWildcard();}
}

void PostfixExpr() #PostfixExpr(>1):
{}
{
    PrimaryExpr() (Predicate() | ArgumentList())*
}

void ArgumentList():
{}
{
    "(" [ Argument() ("," Argument() )* ] ")"
}

void Argument():
{}
{
    ExprSingle() | "?" {jjtThis.setPlaceholder();}// TODO that's called placeholder
}


void PredicateList():
{}
{
    (Predicate())*
}

void Predicate() #void:
{}
{
    "[" Expr() "]"
}


void PrimaryExpr() #void:
{}
{
      NumericLiteral()
    | <STRING_LITERAL>      #StringLiteral
    | ("$" VarName())       #VarRef
    | ("(" [ Expr() ] ")")  #ParenthesizedExpr
    | "."                   #ContextItemExpr
    |
    (LOOKAHEAD (2)
      FunctionCall()
    | FunctionItemExpr() )
}

void NumericLiteral():
{}
{
      <INTEGER_LITERAL> { jjtThis.setIntegerLiteral(); }
    | <DECIMAL_LITERAL> { jjtThis.setDecimalLiteral(); }
    | <DOUBLE_LITERAL>  { jjtThis.setDoubleLiteral();  }
}


void FunctionCall():
{}
{
    EQName() ArgumentList()
}

void FunctionItemExpr():
{}
{
    NamedFunctionRef() | InlineFunctionExpr()
}

void NamedFunctionRef():
{}
{
    EQName() "#" <INTEGER_LITERAL> { jjtThis.setArity(Integer.valueOf(token.getImage())); }
}

void InlineFunctionExpr():
{}
{
    <FUNCTION> ParamList() (<AS> SequenceType())? ("{" Expr() "}") #FunctionBody
}

void ParamList():
{}
{
    "(" [ Param() ("," Param() )* ] ")"
}

void Param():
{}
{
    "$" EQName() [ TypeDeclaration() ]
}


/* Kind tests */

void KindTest() #void: // TODO tag those with an interface
{}
{
      DocumentTest()
    | ElementTest()
    | AttributeTest()
    | SchemaElementTest()
    | SchemaAttributeTest()
    | ProcessingInstructionTest()
    | <COMMENT> "(" ")"             #CommentTest
    | <TEXT> "(" ")"                #TextTest
    | <NAMESPACE_NODE> "(" ")"      #NamespaceNodeTest
    | <NODE> "(" ")"                #AnyKindTest
}


void DocumentTest():
{}
{
    <DOCUMENT_NODE> "(" (ElementTest() | SchemaElementTest())? ")"
}


void ElementTest():
{}
{
    <ELEMENT> "(" [ (ElementName() | "*") #ElementNameOrWildcard [ "," TypeName() [ "?" ]]] ")"
}




void AttributeTest():
{}
{
    <ATTRIBUTE> "(" [ (AttributeName() | "*") #AttributeNameOrWildCard [ "," TypeName() ]] ")"
}


void SchemaAttributeTest():
{}
{
    <SCHEMA_ATTRIBUTE> "(" AttributeName() #AttributeDeclaration ")"
}

void ProcessingInstructionTest():
{}
{
    <PROCESSING_INSTRUCTION> "(" (<NCNAME> | <STRING_LITERAL>)? ")"
}


void SchemaElementTest():
{}
{
    <SCHEMA_ELEMENT> "(" ElementName() #ElementDeclaration ")"
}


/* TYPES */

void SequenceType() :
{}
{
   (<EMPTY_SEQUENCE> "(" ")") #EmptySequenceType
 | ItemType()
   (
     <QUESTION_MARK> {jjtThis.setCardinality(Cardinality.ZERO_OR_ONE);}
   | <STAR>          {jjtThis.setCardinality(Cardinality.ZERO_OR_MORE);}
   | <PLUS>          {jjtThis.setCardinality(Cardinality.ONE_OR_MORE);}
   )?
}

void ItemType():
{}
{
    KindTest()
  | (<ITEM> "(" ")")        #AnyItemType
  | FunctionTest()
  | EQName()                #AtomicOrUnionType
  | ("(" ItemType() ")")    #ParenthesizedItemType
}

void FunctionTest():
{}
{
      LOOKAHEAD (3) (<FUNCTION> "(" <STAR> ")")             #AnyFunctionTest
    | (<FUNCTION> ArgumentTypeList() <AS> SequenceType())   #TypedFunctionTest
}

void ArgumentTypeList():
{}
{
  "(" (SequenceType() ("," SequenceType())*)? ")"
}

void SingleType():
{}
{
  SimpleTypeName() [ "?" {jjtThis.setOptionallyQuantified();} ]
}

void TypeDeclaration():
{}
{
    <AS> SequenceType()
}







// These all produce a Name node

void EQName() #Name:
{}
{
  <EQNAME> | <NCNAME>
}

void NCName() #Name:
{}
{
  <NCNAME>
}


void VarName() #void:
{}
{
   EQName()
}

void AttributeName() #void:
{}
{
   EQName()
}

void ElementName() #void:
{}
{
   EQName()
}


void TypeName() #void:
{}
{
   EQName()
}

void SimpleTypeName() #void:
{}
{
   EQName()
}
