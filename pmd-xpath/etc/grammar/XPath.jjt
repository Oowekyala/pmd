
options {
  JAVA_UNICODE_ESCAPE = true;

  CACHE_TOKENS = true;
  STATIC = false;
  USER_CHAR_STREAM = true;
  JDK_VERSION = "1.6";

  MULTI = true;
  VISITOR = true;
  NODE_USES_PARSER = true;
  TRACK_TOKENS = true;
  NODE_PACKAGE = "net.sourceforge.pmd.lang.xpath.ast";

   DEBUG_PARSER = true;
  // DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(XPathParser)

import net.sourceforge.pmd.lang.ast.CharStream;

public class XPathParser {

    void throwParseException(String message) {
        ParseException exc = generateParseException();
        throw new ParseException(exc.getMessage() + message);
    }


    void checkVarBinding(boolean isLetContext, boolean wasLetFound) {
        String expected = isLetContext ? ":=" : "in";
        String actual = wasLetFound ? ":=" : "in";

        if (isLetContext != wasLetFound) {
          throwParseException("Variable binding expected '" + expected + "', actual '" + actual);
        }
    }

}
PARSER_END(XPathParser)

TOKEN_MGR_DECLS :
{
    private int commentDepth = 0;
}

/* WHITE SPACE */

SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

SKIP :
{
  <"(:"> { commentDepth++; } : IN_XPATH_COMMENT
}

<IN_XPATH_COMMENT> SKIP :
{
  // FIXME Nested comments cannot be expressed with regex
  //  <XPATH_COMMENT: "(:" > { commentDepth++; }
  // |
  <XPATH_COMMENT: ":)" >
  {
    commentDepth--;
    if (commentDepth == 0) {
      SwitchTo(DEFAULT);
    }
  }
}

<IN_XPATH_COMMENT> MORE :
{
  < ~[] >
}

/* RESERVED WORDS */

TOKEN :
{
// Axes
 < SELF: "self" >
| < CHILD: "child" >
| < ATTRIBUTE: "attribute" >
| < DESCENDANT: "descendant" >
| < DESCENDANT_OR_SELF: "descendant-or-self" >
| < ANCESTOR: "ancestor" >
| < ANCESTOR_OR_SELF: "ancestor-or-self" >
| < FOLLOWING: "following" >
| < FOLLOWING_SIBLING: "following-sibling" >
| < NAMESPACE: "namespace" >
| < PARENT: "parent" >
| < PRECEDING: "preceding" >
| < PRECEDING_SIBLING: "preceding-sibling" >

// Operators
| < OR: "or" >
| < AND: "and" >
| < NOT: "not" >
| < DIV: "div" >
| < IDIV: "idiv" >
| < MOD: "mod" >
| < NE: "ne" >
| < EQ: "eq" >
| < LT: "lt" >
| < LE: "le" >
| < GT: "gt" >
| < GE: "ge" >

// Keywords
| < SOME: "some" >
| < IN: "in" >
| < SATISFIES: "satisfies" >
| < AS: "as" >
| < IS: "is" >
| < FOR: "for" >
| < EVERY: "every" >
| < CAST: "cast" >
| < CASTABLE: "castable" >
| < TREAT: "treat" >
| < INSTANCE: "instance" >
| < OF: "of" >
| < TO: "to" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < RETURN: "return" >
| < LET: "let" >
| < INTERSECT: "intersect" >
| < EXCEPT: "except" >
| < UNION: "union" >

// Node kinds
| < NODE: "node" >
| < DOCUMENT_NODE: "document-node" >
| < TEXT: "text" >
| < COMMENT: "comment" >
| < NAMESPACE_NODE: "namespace-node" >
| < PROCESSING_INSTRUCTION: "processing-instruction" >
// | < ATTRIBUTE: "attribute" > // also a node kind, but already defined
| < SCHEMA_ATTRIBUTE: "schema-attribute" >
| < ELEMENT: "element" >
| < SCHEMA_ELEMENT: "schema-element" >
| < FUNCTION: "function" >

// Separators
//| < LPAREN: "(" >
//| < RPAREN: ")" >
//| < LBRACKET: "[" >
//| < RBRACKET: "]" >
//| < SEMICOLON: ";" >
//| < DOUBLE_COLON: "::" >
//| < COMMA: "," >
//| < DOT: "." >
//| < AT: "@" >
//| < DOLLAR: "$" >
}




/* LITERALS */


TOKEN :
{
  < STRING_LITERAL: "\"" ("\"\"" | ~["\""])* "\"" | "'" ("''" | ~["'"])* "'" >
|
  < NUMERIC_LITERAL: <INTEGER_LITERAL> | <DECIMAL_LITERAL> | <DOUBLE_LITERAL> >
|
  < BRACED_URI_LITERAL: "Q" "{" (~["{", "}"])* "}" >
|
  < #DIGITS: (["0"-"9"])+ >
|
  < INTEGER_LITERAL: <DIGITS> >
|
  < #DECIMAL_LITERAL: ("." <DIGITS>) | (<DIGITS> ("." (["0"-"9"])*)) >
|
  < #DOUBLE_LITERAL: (("." <DIGITS>) | (<DIGITS> ("." (["0"-"9"])*)?)) ["e","E"] (["+","-"])? <DIGITS> >
}

/* NAMES */

TOKEN :
{
  // The actual lexical grammar for NCName is: any name except <CHAR>* ":" <CHAR>*
  // This is not easily representable and is left for future work if needed
  < NCNAME: <NAME_START_CHAR_NO_COLON> (<NAME_CHAR_NO_COLON>)* >
|
  < EQNAME: <NCNAME> (":" <NCNAME>)? | <BRACED_URI_LITERAL> <NCNAME> >
|
  < NS_ATT_NAME: "xmlns:" <NCNAME> | "xmlns" >
|
  < #NAME_START_CHAR_NO_COLON: [
    "A"-"Z",
    "a"-"z",
    "_",
    "\u00c0"-"\u00d6",
    "\u00d8"-"\u00f6",
    "\u00f8"-"\u02ff",
    "\u0370"-"\u037d",
    "\u037f"-"\u1fff",
    "\u200c"-"\u200d",
    "\u2070"-"\u218f",
    "\u2c00"-"\u2fef",
    "\u3001"-"\ud7ff",
    "\uf900"-"\ufdcf",
    "\ufdf0"-"\ufffd",
    "\u1000"-"\uefff"
  ] >
|
  < #NAME_CHAR_NO_COLON: <NAME_START_CHAR_NO_COLON> | [
  "-",
  ".",
  "0"-"9",
  "\u00b7",
  "\u0300"-"\u036f",
  "\u203f"-"\u2040"
  ] >
}



/*****************************************
 * THE XPATH LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

ASTXPathRoot XPathRoot() :
{}
{
  Expr() <EOF> { return jjtThis; }
}

void Expr() :
{}
{
  VoidSingleExpr() ("," VoidSingleExpr() )*
}

// This is a shorthand for "An Expr with necessarily one child"
void ExprSingle() #Expr:
{}
{
    VoidSingleExpr()
}

// This factorises the two
void VoidSingleExpr() #void:
{}
{
    ForExpr()
  | LetExpr()
  | QuantifiedExpr()
  | IfExpr()
  | OrExpr()
}



void ForExpr():
{}
{
 "for" VarBindingList(false) "return" ExprSingle()
}

void LetExpr():
{}
{
 "let" VarBindingList(true) "return" ExprSingle()
}

void QuantifiedExpr():
{}
{
  ("some" { jjtThis.setUniversallyQuantified(false); }| "every" {jjtThis.setUniversallyQuantified(true);})
  VarBindingList(false)
  "satisfies" ExprSingle()
}

void VarBindingList(boolean isLetCtx):
{}
{
    VarBinding(isLetCtx) ("," VarBinding(isLetCtx))*
}



void VarBinding(boolean isLet):
{}
{
  "$" VarName() { jjtThis.setVarName(token.getImage()); }
  (<IN> {checkVarBinding(isLet, false);} | ":=" {checkVarBinding(isLet, true);})
  ExprSingle()
}

void IfExpr():
{}
{
  "if" "(" Expr() ")" "then" ExprSingle() "else" ExprSingle()
}

void OrExpr() #OrExpr(>1):
{}
{
  AndExpr() ( "or" AndExpr() )*
}

void AndExpr() #AndExpr(>1):
{}
{
  ComparisonExpr() ( "and" ComparisonExpr() )*
}

void ComparisonExpr() #ComparisonExpr(>1):
{String operator = null;}
{
  StringConcatExpr()
  (
    (operator = ComparisonOperator()) StringConcatExpr() {jjtThis.setOperator(operator);}
  )?
}

String ComparisonOperator() #void: // TODO store operator, do that in the Java node
{}
{
   (  "=" | "!=" | "<" | "<=" | ">" | ">="
   |  "ne" | "eq" | "lt" | "le" | "gt" | "ge"
   |  "is" | "<<" | ">>"
   )
   { return token.getImage(); }
}



void StringConcatExpr() #StringConcatExpr(>1):
{}
{
  RangeExpr() ( "||" RangeExpr() )*
}

void RangeExpr() #RangeExpr(>1):
{}
{
  AdditiveExpr() ( "to" AdditiveExpr() )?
}

// In the following, we use nodes to represent the operators because there may be several expressions chained.
// e.g. E1 + E2 - E3 ~> E1 PlusOperator E2 MinusOperator E3

void AdditiveExpr() #AdditiveExpr(>1):
{}
{
  MultiplicativeExpr() ( ( "+" #PlusOperator | "-" #MinusOperator) MultiplicativeExpr() )*
}

void MultiplicativeExpr() #MultiplicativeExpr(>1):
{}
{
  UnionExpr()
  (
    (   "*" #TimesOperator
      | "div" #DivOperator
      | "idiv" #IDivOperator
      | "mod" #ModOperator
    )

    UnionExpr()
  )*
}

void UnionExpr() #UnionExpr(>1):
{}
{
  IntersectExceptExpr() ( UnionOperator() IntersectExceptExpr() )*
}

void UnionOperator():
{}
{
    "union"
  | "|" { jjtThis.setShorthand(true); }
}

void IntersectExceptExpr() #IntersectExceptExpr(>1):
{}
{
  InstanceofExpr()
  (
    (   "intersect" #IntersectOperator
      | "except" #ExceptOperator
    )

    InstanceofExpr()
  )*
}


void InstanceofExpr() #InstanceofExpr(>1):
{}
{
  TreatExpr() ( "instance" "of" SequenceType() )?
}

void TreatExpr() #TreatExpr(>1):
{}
{
  CastableExpr() ( "treat" "as" SequenceType() )?
}

void CastableExpr() #CastableExpr(>1):
{}
{
  CastExpr() ( LOOKAHEAD (3) "treat" "as" SingleType() )?
}

void CastExpr() #CastExpr(>1):
{}
{
  UnaryExpr() ( "cast" "as" SingleType() )?
}

void UnaryExpr() #UnaryExpr(push):
{ boolean push = false; }
{
      [ < ([ "+" , "-" ])+ > { push = true; } ] MapExpr()
}

void MapExpr() #MapExpr(>1) :
{}
{
 PathExpr() ( "!" PathExpr() )*
}

/* PATH EXPRESSIONS */

void PathExpr() #PathExpr(!trivial):
{ boolean trivial = false; }
{
    ("/" [ RelativePathExpr(false) ]) { jjtThis.setRootAnchor(); }
  | ( "//" RelativePathExpr(false)) { jjtThis.setDescendantAnchor(); }
  | (trivial = RelativePathExpr(true)) { jjtThis.setRelativeAnchor(); }
}

boolean RelativePathExpr(boolean maybeTrivial) #void:
{}
{
  (maybeTrivial = StepExpr(maybeTrivial))
  (
    ( "/" | AbbrevPathOperator()) // "//" is synthesized as a StepExpr for consistency
    StepExpr(false)
    { maybeTrivial = false; }
  )*
  { return maybeTrivial; }
}


void AbbrevPathOperator() #StepExpr:
{}
{
    ("//" { jjtThis.setAbbrevDescendantOrSelf();})
}

// TODO corner cases:
// https://www.w3.org/TR/xpath-30/#doc-xpath30-RelativePathExpr
// / union /* vs (/) union /*
// /* & / * -> pathexpr with wildcard
// /*5 vs / * 5 -> syntax error
// (/) * 5 -> multiplication with root path expr

boolean StepExpr(boolean maybeTrivial) #StepExpr(!maybeTrivial):
{}
{
    (LOOKAHEAD(2) PostfixExpr() | (AxisStep() {maybeTrivial = false;}))
    { return maybeTrivial; }
}

ASTAxisStep AxisStep():
{}
{
 (
   (jjtThis.axis = Axis()) "::" NodeTest()
 |
   NodeTest() { jjtThis.setAbbrevNoAxis(); } // The nodetest is #void, distinctions are implemented with an interface
 |
   "@" NodeTest() { jjtThis.setAbbrevAttributeAxis(); }
 |
   ".." { jjtThis.setAbbrevParentNodeTest();  }
 )
 PredicateList()
 { return jjtThis; }
}

// Only the AxisStep is pushed on the stack

Axis Axis() #void:
{
  // It's a child if this production only matches the NodeTest
  Axis axis = null;
}
{
    ( <SELF> { axis = Axis.SELF;}
    | <CHILD> { axis = Axis.CHILD; }
    | <ATTRIBUTE> { axis = Axis.ATTRIBUTE; }
    | <DESCENDANT> { axis = Axis.DESCENDANT; }
    | <DESCENDANT_OR_SELF> { axis = Axis.DESCENDANT_OR_SELF; }
    | <FOLLOWING> { axis = Axis.FOLLOWING; }
    | <FOLLOWING_SIBLING> { axis = Axis.FOLLOWING_SIBLING; }
    | <NAMESPACE> { axis = Axis.NAMESPACE; }
    | <PARENT> { axis = Axis.PARENT; }
    | <ANCESTOR> { axis = Axis.ANCESTOR; }
    | <ANCESTOR_OR_SELF> { axis = Axis.ANCESTOR_OR_SELF; }
    | <PRECEDING_SIBLING> { axis = Axis.PRECEDING_SIBLING; }
    | <PRECEDING> { axis = Axis.PRECEDING; }
    )
    { return axis; }
}

NodeTest NodeTest() #void:
{}
{
    (KindTest() | NameTest()) // both of these are #void
    { return (NodeTest) jjtree.peekNode(); } // Returns the last node to have been pushed
}

void NameTest() #void:
{}
{
   LOOKAHEAD(2) ExactNameTest() | WildcardNameTest()
}

void ExactNameTest():
{}
{
    EQName()
}

void WildcardNameTest():
{}
{
      "*" [ ":" NCName() {jjtThis.setPrefixWildcard();} ]
    | NCName() ":" "*" {jjtThis.setLocalNameWildcard();}
    | <BRACED_URI_LITERAL> "*" {jjtThis.setLocalNameWildcard();}
}

void PostfixExpr() #PostfixExpr(>1):
{}
{
    PrimaryExpr() (Predicate() | ArgumentList())*
}

void ArgumentList():
{}
{
    "(" [ Argument() ("," Argument() )* ] ")"
}

void Argument():
{}
{
    ExprSingle() | "?" {jjtThis.setPlaceholder();}// TODO that's called placeholder
}


void PredicateList():
{}
{
    (Predicate())*
}

void Predicate() #void:
{}
{
    "[" Expr() "]"
}


void PrimaryExpr() #void:
{}
{
      <NUMERIC_LITERAL>     #NumericLiteral
    | <STRING_LITERAL>      #StringLiteral
    | "$" VarName()         #VarRef
    | "(" [ Expr() ] ")"    #ParenthesizedExpr
    | "."                   #ContextItemExpr
    | ( LOOKAHEAD (2) FunctionCall()
    | FunctionItemExpr() )
}

void FunctionCall():
{}
{
    EQName() ArgumentList()
}

void FunctionItemExpr():
{}
{
    NamedFunctionRef() | InlineFunctionExpr()
}

void NamedFunctionRef():
{}
{
    EQName() "#" <INTEGER_LITERAL> { jjtThis.setArity(Integer.valueOf(token.getImage())); }
}

void InlineFunctionExpr():
{}
{
    "function" ParamList() ("as" SequenceType())? ("{" Expr() "}") #FunctionBody
}

void ParamList():
{}
{
    "(" [ Param() ("," Param() )* ] ")"
}

void Param():
{}
{
    "$" EQName() [ TypeDeclaration() ]
}


/* Kind tests */

void KindTest() #void: // TODO tag those with an interface
{}
{
      DocumentTest()
    | ElementTest()
    | AttributeTest()
    | SchemaElementTest()
    | SchemaAttributeTest()
    | ProcessingInstructionTest()
    | "comment" "(" ")"             #CommentTest
    | "text" "(" ")"                #TextTest
    | "namespace-node" "(" ")"      #NamespaceNodeTest
    | "node" "(" ")"                #AnyKindTest
}


void DocumentTest():
{}
{
    "document-node" "(" (ElementTest() | SchemaElementTest())? ")"
}


void ElementTest():
{}
{
    "element" "(" [ (ElementName() | "*") #ElementNameOrWildcard [ "," TypeName() [ "?" ]]] ")"
}




void AttributeTest():
{}
{
    <ATTRIBUTE> "(" [ (AttributeName() | "*") #AttributeNameOrWildCard [ "," TypeName() ]] ")"
}


void SchemaAttributeTest():
{}
{
    "schema-attribute" "(" AttributeName() #AttributeDeclaration ")"
}

void ProcessingInstructionTest():
{}
{
    "processing-instruction" "(" (<NCNAME> | <STRING_LITERAL>)? ")"
}


void SchemaElementTest():
{}
{
    "schema-element" "(" ElementName() #ElementDeclaration ")"
}


/* TYPES */

void SequenceType() :
{}
{
   "empty-sequence" "(" ")" #EmptySequenceType
 | ItemType()
   (
      "?" {jjtThis.setCardinality(Cardinality.ZERO_OR_ONE);}
    | "*" {jjtThis.setCardinality(Cardinality.ZERO_OR_MORE);}
    | "+" {jjtThis.setCardinality(Cardinality.ONE_OR_MORE);}
   )?
}

void ItemType():
{}
{
    KindTest()
  | "item" "(" ")"          #AnyItemType
  | FunctionTest()
  | EQName()                #AtomicOrUnionType
  | "(" ItemType() ")"      #ParenthesizedItemType
}

void FunctionTest():
{}
{
      LOOKAHEAD (3) ("function" "(" "*" ")")                #AnyFunctionTest
    | ("function" ArgumentTypeList() "as" SequenceType())   #TypedFunctionTest
}

void ArgumentTypeList():
{}
{
  "(" (SequenceType() ("," SequenceType())*)? ")"
}

void SingleType():
{}
{
  SimpleTypeName() [ "?" {jjtThis.setOptionallyQuantified();} ]
}

void TypeDeclaration():
{}
{
    "as" SequenceType()
}







// These all produce a Name node

void EQName() #Name:
{}
{
  <EQNAME> | <NCNAME>
}

void NCName() #Name:
{}
{
  <NCNAME>
}


void VarName() #void:
{}
{
   EQName()
}

void AttributeName() #void:
{}
{
   EQName()
}

void ElementName() #void:
{}
{
   EQName()
}


void TypeName() #void:
{}
{
   EQName()
}

void SimpleTypeName() #void:
{}
{
   EQName()
}
